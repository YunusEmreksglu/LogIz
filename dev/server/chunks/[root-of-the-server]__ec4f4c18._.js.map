{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 106, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/asus/Desktop/LogIz/LogIz-LogIz/lib/supabase.ts"],"sourcesContent":["import { createClient } from '@supabase/supabase-js'\r\n\r\nconst supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || 'https://tmavagzxznmmwecbudux.supabase.co'\r\nconst supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || process.env.SUPABASE_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRtYXZhZ3p4em5tbXdlY2J1ZHV4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjI3MDAwMzksImV4cCI6MjA3ODI3NjAzOX0.mkHQy0e3LN0hZfxEmnin5dpgycWJ6NHOp5fltrFUQF8'\r\n\r\nif (!supabaseKey) {\r\n    console.warn('⚠️ Supply a SUPABASE_KEY to use the Supabase client.')\r\n}\r\n\r\nexport const supabase = createClient(supabaseUrl, supabaseKey)\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,cAAc,gFAAwC;AAC5D,MAAM,cAAc,wPAA6C,QAAQ,GAAG,CAAC,YAAY,IAAI;AAE7F;;AAIO,MAAM,WAAW,IAAA,yLAAY,EAAC,aAAa","debugId":null}},
    {"offset": {"line": 121, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/asus/Desktop/LogIz/LogIz-LogIz/lib/auth.ts"],"sourcesContent":["import { NextAuthOptions } from \"next-auth\"\r\nimport CredentialsProvider from \"next-auth/providers/credentials\"\r\nimport { supabase } from \"@/lib/supabase\"\r\nimport bcrypt from \"bcryptjs\"\r\n\r\nexport const authOptions: NextAuthOptions = {\r\n  providers: [\r\n    CredentialsProvider({\r\n      name: \"credentials\",\r\n      credentials: {\r\n        email: { label: \"Email\", type: \"email\" },\r\n        password: { label: \"Password\", type: \"password\" }\r\n      },\r\n      async authorize(credentials) {\r\n        if (!credentials?.email || !credentials?.password) {\r\n          throw new Error(\"Email and password required\")\r\n        }\r\n\r\n        // Fetch user from Supabase 'users' table\r\n        const { data: user, error } = await supabase\r\n          .from('users')\r\n          .select('*')\r\n          .eq('email', credentials.email)\r\n          .single()\r\n\r\n        if (error || !user || !user.password) {\r\n          throw new Error(\"Invalid credentials\")\r\n        }\r\n\r\n        const isPasswordValid = await bcrypt.compare(\r\n          credentials.password,\r\n          user.password\r\n        )\r\n\r\n        if (!isPasswordValid) {\r\n          throw new Error(\"Invalid credentials\")\r\n        }\r\n\r\n        return {\r\n          id: user.id,\r\n          email: user.email,\r\n          name: user.name,\r\n          role: user.role,\r\n        }\r\n      }\r\n    })\r\n  ],\r\n  session: {\r\n    strategy: \"jwt\"\r\n  },\r\n  pages: {\r\n    signIn: \"/login\",\r\n  },\r\n  callbacks: {\r\n    async jwt({ token, user }) {\r\n      if (user) {\r\n        token.id = user.id\r\n        token.role = user.role\r\n      }\r\n      return token\r\n    },\r\n    async session({ session, token }) {\r\n      if (session.user) {\r\n        session.user.id = token.id as string\r\n        session.user.role = token.role as string\r\n      }\r\n      return session\r\n    }\r\n  },\r\n  secret: process.env.NEXTAUTH_SECRET || \"development_secret_key_123\",\r\n}\r\n"],"names":[],"mappings":";;;;AACA;AACA;AACA;;;;AAEO,MAAM,cAA+B;IAC1C,WAAW;QACT,IAAA,qKAAmB,EAAC;YAClB,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW;gBACzB,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,MAAM,IAAI,MAAM;gBAClB;gBAEA,yCAAyC;gBACzC,MAAM,EAAE,MAAM,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,6HAAQ,CACzC,IAAI,CAAC,SACL,MAAM,CAAC,KACP,EAAE,CAAC,SAAS,YAAY,KAAK,EAC7B,MAAM;gBAET,IAAI,SAAS,CAAC,QAAQ,CAAC,KAAK,QAAQ,EAAE;oBACpC,MAAM,IAAI,MAAM;gBAClB;gBAEA,MAAM,kBAAkB,MAAM,8IAAM,CAAC,OAAO,CAC1C,YAAY,QAAQ,EACpB,KAAK,QAAQ;gBAGf,IAAI,CAAC,iBAAiB;oBACpB,MAAM,IAAI,MAAM;gBAClB;gBAEA,OAAO;oBACL,IAAI,KAAK,EAAE;oBACX,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;oBACf,MAAM,KAAK,IAAI;gBACjB;YACF;QACF;KACD;IACD,SAAS;QACP,UAAU;IACZ;IACA,OAAO;QACL,QAAQ;IACV;IACA,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;gBAClB,MAAM,IAAI,GAAG,KAAK,IAAI;YACxB;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBAChB,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;gBAC1B,QAAQ,IAAI,CAAC,IAAI,GAAG,MAAM,IAAI;YAChC;YACA,OAAO;QACT;IACF;IACA,QAAQ,QAAQ,GAAG,CAAC,eAAe,IAAI;AACzC","debugId":null}},
    {"offset": {"line": 195, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/asus/Desktop/LogIz/LogIz-LogIz/app/api/traffic/trend/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server'\r\nimport { createClient } from '@supabase/supabase-js'\r\nimport { getServerSession } from 'next-auth'\r\nimport { authOptions } from '@/lib/auth'\r\n\r\nexport async function GET(request: Request) {\r\n    try {\r\n        // Use Service Role client for public access\r\n        const supabaseAdmin = createClient(\r\n            process.env.NEXT_PUBLIC_SUPABASE_URL!,\r\n            process.env.SUPABASE_SERVICE_ROLE_KEY!,\r\n            {\r\n                auth: {\r\n                    autoRefreshToken: false,\r\n                    persistSession: false\r\n                }\r\n            }\r\n        )\r\n\r\n        const session = await getServerSession(authOptions)\r\n        const userId = session?.user?.id\r\n\r\n        // Default range 24h\r\n        const { searchParams } = new URL(request.url)\r\n        const range = searchParams.get('range') || '24h'\r\n\r\n        let hours = 24\r\n        if (range === '12h') hours = 12\r\n        if (range === '6h') hours = 6\r\n\r\n        // Calculate start date\r\n        const startDate = new Date()\r\n        const now = new Date()\r\n        startDate.setHours(startDate.getHours() - hours)\r\n\r\n        // Fetch log files uploaded in this range\r\n        let query = supabaseAdmin\r\n            .from('log_files')\r\n            .select('file_size, uploaded_at')\r\n            .gte('uploaded_at', startDate.toISOString())\r\n            .order('uploaded_at', { ascending: true })\r\n\r\n        if (userId) {\r\n            query = query.eq('user_id', userId)\r\n        }\r\n\r\n        const { data: logFiles, error } = await query\r\n\r\n        if (error) throw error\r\n\r\n        // Initialize buckets for each hour in the range\r\n        // We want data points for every hour from start to now\r\n        const trendData: { time: string; upload: number; download: number }[] = []\r\n        const bucketMap = new Map<number, { upload: number; download: number }>()\r\n\r\n        // Fill buckets with 0\r\n        for (let i = 0; i <= hours; i++) {\r\n            const d = new Date(now)\r\n            d.setHours(d.getHours() - i)\r\n            // We use hour as key. Beware of day wrapping. \r\n            // Better to use full timestamp or just simplistic hour for 24h view.\r\n            // For correct sorting, let's just push to array at the end.\r\n            // Actually, let's map by \"Day-Hour\" string to be safe or just epoch hour.\r\n            // Simpler: Just create the structure first.\r\n        }\r\n\r\n        // Correct approach: generate labels and init map\r\n        const labels: string[] = []\r\n        // We want to return exactly 'hours' + 1 points roughly, or just covering the range.\r\n        // Let's iterate from startDate to now by hour.\r\n\r\n        const current = new Date(startDate)\r\n        // reset minutes to 0 for cleaner buckets\r\n        current.setMinutes(0, 0, 0)\r\n\r\n        while (current <= now) {\r\n            const hour = current.getHours()\r\n            const timeLabel = `${hour}:00`\r\n            // Use timeLabel as key for simplicity in this view, assuming < 24h range handles wrapping? \r\n            // If range is 24h, we might have two \"12:00\" (yesterday and today). \r\n            // So we need unique keys.\r\n            const key = current.getTime()\r\n\r\n            bucketMap.set(key, { upload: 0, download: 0 })\r\n            current.setHours(current.getHours() + 1)\r\n        }\r\n\r\n        logFiles?.forEach(file => {\r\n            const d = new Date(file.uploaded_at)\r\n            d.setMinutes(0, 0, 0)\r\n            const key = d.getTime()\r\n\r\n            // Find closest bucket? Or exact match. \r\n            // Log timestamp might not be exact hour zero.\r\n            // Let's round to nearest hour or floor.\r\n\r\n            // Re-calculate simplistic buckets:\r\n            // Find the bucket in bucketMap that is closest or equal (floored hour)\r\n\r\n            // Optimization: Just floor the log time to hour\r\n            const logTime = new Date(file.uploaded_at)\r\n            logTime.setMinutes(0, 0, 0)\r\n            const logKey = logTime.getTime()\r\n\r\n            if (bucketMap.has(logKey)) {\r\n                const currentVal = bucketMap.get(logKey)!\r\n                // Convert bytes to KB for chart (visuals look better) or MB?\r\n                // Chart component divided by 1000 in tickFormatter, implying it expects values compatible with that.\r\n                // Let's return Bytes and let chart handle, OR return KB.\r\n                // Component: tickFormatter={(value) => `${(value / 1000).toFixed(1)}K`}\r\n                // If we send Bytes: 1000000 bytes = 1000K = 1M. \r\n                // Let's send KB directly? \r\n                // Previous code: vals.upload * 1024 (MB * 1024 = KB).\r\n\r\n                const sizeKB = file.file_size ? file.file_size / 1024 : 0\r\n                currentVal.upload += sizeKB\r\n\r\n                // Simulate download/processing traffic as a factor of upload\r\n                currentVal.download += sizeKB * 1.2\r\n\r\n                bucketMap.set(logKey, currentVal)\r\n            }\r\n        })\r\n\r\n        // Convert map to array sorted by time\r\n        const sortedKeys = Array.from(bucketMap.keys()).sort((a, b) => a - b)\r\n\r\n        sortedKeys.forEach(key => {\r\n            const d = new Date(key)\r\n            const hour = d.getHours()\r\n            const val = bucketMap.get(key)!\r\n\r\n            trendData.push({\r\n                time: `${hour}:00`,\r\n                upload: Math.round(val.upload),\r\n                download: Math.round(val.download)\r\n            })\r\n        })\r\n\r\n        return NextResponse.json({ success: true, data: trendData })\r\n\r\n    } catch (error) {\r\n        console.error('Traffic trend error:', error)\r\n        return NextResponse.json(\r\n            { error: 'Failed to fetch traffic trend' },\r\n            { status: 500 }\r\n        )\r\n    }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}